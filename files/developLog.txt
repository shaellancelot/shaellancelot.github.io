CArchitecture开发日志

1、现在整体框架还是针对多个testcase的，采用CMgrJob控制testcase list
2、每个testcase都经过reading、parsing、modeling、writing阶段
3、在modeling以后可以形成hMetis格式的超图结构，也可以将这种超图结构当做参数传入我们自己的分割算法
4、我们将3中提到的超图结构转化为邻接表格式的超图，pAllEdges邻接表保存所有的超边，pAllVertices保存所有顶点
5、在每次二分的时候，将原始超图分割成两个子超图，用指针leftSon和rightSon保存这两个子超图地址，再针对小超图进行迭代二分
6、每个子超图中保存了其父超图的指针fatherGraph，并且保存了其顶点编号对其父超图顶点编号的映射
7、二分的选种过程采用了MHEC的方法，先将原超图收缩到一定程度，在该基础上随机选种，在回映到原超图的顶点，进行BFS的二分


算法思想：

parser: 以类为顶点，调用同一个类的所有类和被调用类一起构成一条超边，顶点权重和超边权重都设为1，构建超图

1、采用多线程的编程思想，将所有的I/O用操作集成都同一个类管理，并将cpu可以分割并行的任务分交给多个线程，保证了cpu的计算和IO的并行，减少了程序运行时间

超图分割：
1、超图选种，如果直接随机选种，不能保证选种均匀分布在超图各处，对于大边的顶点，往往会有多次被选择成为种子，这样就会导致重复计算，加大计算量，而且不能得到较优的结果。为了使超图的选种分布的更加均匀，将超图的属于同一超边的顶点合并成一个顶点，构建成一邻居超图，进行迭代合并，形成k邻居超图，在再k邻居超图中随机选择n个种子，往回映射到原始超图，这样就可保重随机的n个种子分布在比较均匀的区域。
2、选定种子以后，以该种子为起点，沿着超边进行bfs，权重大的超边优先，直到剩余的顶点数不多于全部顶点数的一半，停止bfs，这样就将超图分割成顶点数基本相等的两半。
3、保存被切割的超边，同时保存这些超边上的顶点作为切割点。算出每个切割点，假设移动到另一部分，模块度的增加值gain，将gain值保存在大顶堆中，从大顶堆中取出gain值最大的切割点，移动它到另一部分，并将其固定，然后进栈。如果移动的切割点，导致了某一条或者多条的切边状态的变化，则更新大顶堆里面的每个顶点的gain值，调整大顶堆。
4、一直在大顶堆中选择最大的gain值的顶点进行移动，gain值相同的先考虑大边，移动后，固定改顶点，并将该顶点移动后的模块度进栈，当移动顶点达到所设上限m或者切割点都被移完时，停止移动。退栈，并回复顶点的原始状态，直到找到最大模块度。 按照这时的切割情况，分割超图。

5、分割后，形成两个子超图，对于属于同一子超图并且属于同一切边的顶点之间，构建一条权值为0的超边
6、对子超图在进行分割。直到找到的最大的模块度值少于临界值时，停止划分。

如此，就将超图分割成了多个部分